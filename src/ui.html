<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design Token Export</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 20px;
      font-size: 12px;
      color: #333;
    }
    
    h2 {
      margin-bottom: 16px;
      font-size: 16px;
      font-weight: 600;
    }
    
    h3 {
      margin-top: 16px;
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 500;
    }
    
    p {
      margin-bottom: 16px;
      color: #666;
    }
    
    button {
      background-color: #18a0fb;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      margin-right: 8px;
      margin-top: 16px;
      cursor: pointer;
      font-weight: 500;
    }
    
    button:hover {
      background-color: #0d8ce0;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .selection-group {
      margin-top: 16px;
      margin-bottom: 16px;
      padding: 12px;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
      background-color: #f9f9f9;
    }
    
    .option-group {
      margin-top: 16px;
      margin-bottom: 16px;
      padding: 12px;
      border: 1px solid #e5e5e5;
      border-radius: 4px;
      background-color: #f0f7ff;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .collection-item {
      margin-bottom: 12px;
    }
    
    .collection-header {
      display: flex;
      align-items: center;
      font-weight: 500;
      margin-bottom: 4px;
      cursor: pointer;
    }
    
    .collection-modes {
      margin-left: 24px;
      padding-top: 4px;
    }
    
    .checkbox-item label {
      margin-left: 8px;
      cursor: pointer;
    }
    
    .radio-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .radio-item label {
      margin-left: 8px;
      cursor: pointer;
    }
    
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow: auto;
      max-height: 300px;
      font-family: monospace;
      font-size: 11px;
    }
    
    #status {
      margin-top: 16px;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .info {
      background-color: #e8f4fd;
      color: #0366d6;
    }
    
    .success {
      background-color: #e6ffed;
      color: #22863a;
    }
    
    .warning {
      background-color: #fff8e1;
      color: #b08800;
    }
    
    .error {
      background-color: #ffeef0;
      color: #d73a49;
    }
    
    .loading {
      display: flex;
      align-items: center;
      font-style: italic;
      color: #666;
    }
    
    .spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 8px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .select-all {
      font-size: 11px;
      color: #0366d6;
      cursor: pointer;
      margin-left: 16px;
    }
    
    .validation-tools {
      margin-top: 16px;
      padding-top: 8px;
      border-top: 1px solid #e5e5e5;
    }
    
    .pill {
      display: inline-block;
      padding: 2px 8px;
      margin-right: 4px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 500;
      background-color: #e1f5fe;
      color: #0277bd;
    }
    
    .export-options {
      margin-top: 16px;
      display: flex;
      gap: 8px;
    }
    
    .dropdown-select {
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: white;
      font-size: 12px;
    }
    
    .preview-tabs {
      display: flex;
      margin-bottom: 10px;
      border-bottom: 1px solid #e1e4e8;
    }
    
    .preview-tab {
      padding: 6px 12px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: 3px 3px 0 0;
      margin-right: 4px;
      font-size: 11px;
    }
    
    .preview-tab.active {
      background-color: #f5f5f5;
      border-color: #e1e4e8;
      font-weight: 500;
    }
    
    .preview-content {
      display: none;
    }
    
    .preview-content.active {
      display: block;
    }
    
    .expand-collapse {
      margin-left: 8px;
      color: #666;
      font-size: 12px;
      cursor: pointer;
    }
    
    .validation-badge {
      display: inline-block;
      margin-left: 10px;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 500;
    }
    
    .validation-badge.valid {
      background-color: #e6ffed;
      color: #22863a;
    }
    
    .validation-badge.invalid {
      background-color: #ffeef0;
      color: #d73a49;
    }
    
    .chevron {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-right: 4px;
      border-right: 2px solid #666;
      border-bottom: 2px solid #666;
      transform: rotate(-45deg);
      transition: transform 0.2s;
    }
    
    .chevron.collapsed {
      transform: rotate(45deg);
    }
    
    .validation-status {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      padding: 8px;
      border-radius: 4px;
    }
    
    .validation-status.success {
      background-color: #e6ffed;
    }
    
    .validation-status.error {
      background-color: #ffeef0;
    }
    
    .validation-status-icon {
      margin-right: 8px;
      font-size: 16px;
    }
    
    .validation-status-message {
      flex-grow: 1;
    }
  </style>
</head>
<body>
  <h2>Design Token Export</h2>
  <p>Extract your Figma design variables as DTCG-compliant design tokens.</p>
  
  <div id="content">
    <div class="option-group">
      <h3>Format Options</h3>
      <div class="radio-item">
        <input type="radio" id="format-dtcg" name="format" value="dtcg" checked>
        <label for="format-dtcg">DTCG Format (Design Tokens Community Group)</label>
      </div>
      <div class="radio-item">
        <input type="radio" id="format-legacy" name="format" value="legacy">
        <label for="format-legacy">Legacy Format (Simple JSON)</label>
      </div>
      
      <h3>Export Options</h3>
      <div class="checkbox-item">
        <input type="checkbox" id="separate-files" checked>
        <label for="separate-files">Export separate files (one per collection/mode)</label>
      </div>
      
      <div class="checkbox-item">
        <input type="checkbox" id="validate-references" checked>
        <label for="validate-references">Validate and fix references</label>
      </div>
      
      <div class="checkbox-item">
        <input type="checkbox" id="flat-structure">
        <label for="flat-structure">Generate flat structure (easier reference resolution)</label>
      </div>
    </div>
    
    <div class="selection-group">
      <h3>Collections and Modes <span class="select-all" id="toggle-all-collections">Select All</span></h3>
      <div id="collections-and-modes">
        <div class="loading">
          <div class="spinner"></div>
          Loading collections and modes...
        </div>
      </div>
    </div>
    
    <div id="validation-status" style="display: none;">
      <!-- This will be populated with validation status -->
    </div>
    
    <div id="preview-container">
      <h3>Preview</h3>
      <div class="preview-tabs" id="preview-tabs">
        <!-- Tabs will be dynamically generated -->
        <div class="preview-tab active" data-tab="combined">Combined</div>
      </div>
      <div class="preview-contents" id="preview-contents">
        <div class="preview-content active" id="preview-combined">
          <pre id="output">Loading data...</pre>
        </div>
        <!-- Individual previews will be added here -->
      </div>
    </div>
    
    <div>
      <button id="extract-btn">Refresh Tokens</button>
      <button id="download-btn" disabled>Download JSON</button>
      <button id="validate-btn">Validate References</button>
    </div>
  </div>
  
  <div id="status" class="info">Waiting for data...</div>

  <script>
    // Store the extracted tokens
    let tokenData = null;
    let selectedCollections = [];
    let selectedModes = {};  // Changed to an object for better collection-mode tracking
    let areAllCollectionsSelected = true;
    let referenceProblems = [];
    let currentPreviewTab = 'combined';
    
    // DOM elements
    const outputEl = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const downloadBtn = document.getElementById('download-btn');
    const extractBtn = document.getElementById('extract-btn');
    const validateBtn = document.getElementById('validate-btn');
    const collectionsAndModesEl = document.getElementById('collections-and-modes');
    const toggleAllCollectionsBtn = document.getElementById('toggle-all-collections');
    const validateReferencesCheckbox = document.getElementById('validate-references');
    const flatStructureCheckbox = document.getElementById('flat-structure');
    const separateFilesCheckbox = document.getElementById('separate-files');
    const formatDTCGRadio = document.getElementById('format-dtcg');
    const formatLegacyRadio = document.getElementById('format-legacy');
    const previewTabsEl = document.getElementById('preview-tabs');
    const previewContentsEl = document.getElementById('preview-contents');
    const validationStatusEl = document.getElementById('validation-status');
    
    // Helper function to prettify JSON for display
    function prettifyJson(json) {
      return JSON.stringify(json, null, 2);
    }
    
    // Helper function to filter tokens based on selected collections and modes
    function getFilteredTokens() {
      if (!tokenData || selectedCollections.length === 0) return {};
      
      const result = {};
      
      // Process each selected collection
      for (const collection of selectedCollections) {
        if (tokenData[collection]) {
          result[collection] = {};
          
          // Only include selected modes for this collection
          if (selectedModes[collection] && selectedModes[collection].length > 0) {
            for (const mode of selectedModes[collection]) {
              if (tokenData[collection][mode]) {
                result[collection][mode] = tokenData[collection][mode];
              }
            }
          }
          
          // Remove collection if it has no modes after filtering
          if (Object.keys(result[collection]).length === 0) {
            delete result[collection];
          }
        }
      }
      
      // If flat structure is requested, flatten the tokens
      if (flatStructureCheckbox.checked) {
        return flattenTokens(result);
      }
      
      return result;
    }
    
    // Helper to get individual files for separate export
    function getSeparateFiles() {
      const filteredData = getFilteredTokens();
      const files = [];
      
      // If it's a flat structure, create one file per collection
      if (flatStructureCheckbox.checked) {
        // In a flat structure, group by collection and mode prefixes
        const prefixes = new Set();
        for (const key in filteredData) {
          const parts = key.split('.');
          if (parts.length >= 2) {
            prefixes.add(`${parts[0]}.${parts[1]}`);
          }
        }
        
        for (const prefix of prefixes) {
          const [collection, mode] = prefix.split('.');
          const fileData = {};
          
          for (const key in filteredData) {
            if (key.startsWith(prefix)) {
              // Remove the prefix for cleaner structure
              const newKey = key.substring(prefix.length + 1);
              fileData[newKey] = filteredData[key];
            }
          }
          
          if (Object.keys(fileData).length > 0) {
            files.push({
              name: `${collection}-${mode}.json`,
              data: fileData
            });
          }
        }
      } else {
        // For nested structure, create one file per collection/mode
        for (const collection in filteredData) {
          for (const mode in filteredData[collection]) {
            files.push({
              name: `${collection}-${mode}.json`,
              data: { [collection]: { [mode]: filteredData[collection][mode] } }
            });
          }
        }
      }
      
      // Also add a combined file
      files.push({
        name: 'design-tokens-all.json',
        data: filteredData
      });
      
      return files;
    }
    
    // Function to flatten nested token structure
    function flattenTokens(tokens) {
      const flatResult = {};
      
      function processCollection(collection, mode, path, obj) {
        for (const key in obj) {
          const newPath = path ? `${path}.${key}` : key;
          const value = obj[key];
          
          // If DTCG format and it has a $value field
          if (value && typeof value === 'object' && '$value' in value) {
            // Create the flattened key
            const flatKey = `${collection}.${mode}.${newPath}`;
            flatResult[flatKey] = {...value}; // Clone to avoid modifying original
          } 
          // If it's a nested object but not a token, recurse
          else if (value && typeof value === 'object' && !('$value' in value)) {
            processCollection(collection, mode, newPath, value);
          } 
          // For legacy format (direct values)
          else if (value !== undefined && value !== null && typeof value !== 'object') {
            const flatKey = `${collection}.${mode}.${newPath}`;
            
            // For legacy format, create a simple value
            if (formatLegacyRadio.checked) {
              flatResult[flatKey] = value;
            } 
            // For DTCG format, create a DTCG token
            else {
              flatResult[flatKey] = {
                $value: value,
                $type: inferType(value)
              };
            }
          }
        }
      }
      
      // Process each collection and mode
      for (const collection in tokens) {
        for (const mode in tokens[collection]) {
          processCollection(collection, mode, '', tokens[collection][mode]);
        }
      }
      
      return flatResult;
    }
    
    // Helper function to infer type from value for flat structure
    function inferType(value) {
      if (typeof value === 'string') {
        if (value.startsWith('#') || value.startsWith('rgb')) {
          return 'color';
        } else if (value.match(/\d+(\.\d+)?(px|rem|em|%)/)) {
          return 'dimension';
        } else if (value.startsWith('{') && value.endsWith('}')) {
          return 'reference';
        }
        return 'string';
      } else if (typeof value === 'number') {
        return 'number';
      } else if (typeof value === 'boolean') {
        return 'boolean';
      }
      return 'string'; // Default
    }
    
    // Function to validate references in token set
    function validateReferences(tokens) {
      const problems = [];
      const references = new Map();
      
      // First pass: collect all token paths
      function collectPaths(obj, path = '') {
        if (!obj || typeof obj !== 'object') return;
        
        // Skip non-objects
        if (Array.isArray(obj)) return;
        
        // Check if this is a DTCG token
        if (obj.$value !== undefined) {
          references.set(path, obj.$value);
          return;
        }
        
        // Process nested objects
        for (const key in obj) {
          const newPath = path ? `${path}/${key}` : key;
          const value = obj[key];
          
          if (typeof value === 'object' && value !== null) {
            collectPaths(value, newPath);
          } else {
            // For legacy format with direct values
            references.set(newPath, value);
          }
        }
      }
      
      // Second pass: validate references
      function checkReferences(obj, path = '') {
        if (!obj || typeof obj !== 'object') return;
        
        // Skip non-objects and arrays
        if (Array.isArray(obj)) return;
        
        // If it's a DTCG token with a reference value
        if (obj.$value && typeof obj.$value === 'string' && 
            obj.$value.startsWith('{') && obj.$value.endsWith('}')) {
          
          const refPath = obj.$value.substring(1, obj.$value.length - 1);
          
          // Check if reference exists in our tokens
          let found = false;
          for (const [tokenPath, tokenValue] of references.entries()) {
            if (tokenPath === refPath || tokenPath.endsWith(`/${refPath}`)) {
              found = true;
              break;
            }
          }
          
          if (!found) {
            problems.push({
              path: path,
              reference: refPath,
              message: `Reference '${refPath}' not found in tokens`
            });
          }
        }
        
        // Process nested objects
        for (const key in obj) {
          const newPath = path ? `${path}/${key}` : key;
          const value = obj[key];
          
          if (typeof value === 'object' && value !== null) {
            checkReferences(value, newPath);
          } 
          // For legacy format, check string references
          else if (typeof value === 'string' && 
                   value.startsWith('{') && value.endsWith('}')) {
            
            const refPath = value.substring(1, value.length - 1);
            
            // Check if reference exists in our tokens
            let found = false;
            for (const [tokenPath, tokenValue] of references.entries()) {
              if (tokenPath === refPath || tokenPath.endsWith(`/${refPath}`)) {
                found = true;
                break;
              }
            }
            
            if (!found) {
              problems.push({
                path: newPath,
                reference: refPath,
                message: `Reference '${refPath}' not found in tokens`
              });
            }
          }
        }
      }
      
      // Execute the validation
      for (const collection in tokens) {
        for (const mode in tokens[collection]) {
          collectPaths(tokens[collection][mode], `${collection}/${mode}`);
        }
      }
      
      for (const collection in tokens) {
        for (const mode in tokens[collection]) {
          checkReferences(tokens[collection][mode], `${collection}/${mode}`);
        }
      }
      
      return problems;
    }
    
    // Function to update all previews based on selections
    function updatePreviews() {
      // Update combined preview
      const filteredData = getFilteredTokens();
      document.getElementById('output').textContent = prettifyJson(filteredData);
      
      // If separate files are enabled, update individual previews
      if (separateFilesCheckbox.checked) {
        const files = getSeparateFiles();
        
        // Update or create preview tabs and content for each file
        files.forEach(file => {
          const tabId = `tab-${file.name.replace(/\./g, '-')}`;
          const contentId = `preview-${file.name.replace(/\./g, '-')}`;
          
          // Create tab if it doesn't exist
          if (!document.getElementById(tabId)) {
            const tab = document.createElement('div');
            tab.className = 'preview-tab';
            tab.id = tabId;
            tab.dataset.tab = contentId;
            tab.textContent = file.name;
            tab.addEventListener('click', () => switchPreviewTab(contentId));
            previewTabsEl.appendChild(tab);
            
            // Create content container
            const content = document.createElement('div');
            content.className = 'preview-content';
            content.id = contentId;
            
            const pre = document.createElement('pre');
            content.appendChild(pre);
            
            previewContentsEl.appendChild(content);
          }
          
          // Update content
          const pre = document.querySelector(`#${contentId} pre`);
          if (pre) {
            pre.textContent = prettifyJson(file.data);
          }
        });
        
        // Remove any tabs that are no longer needed
        const allTabs = previewTabsEl.querySelectorAll('.preview-tab:not([data-tab="combined"])');
        allTabs.forEach(tab => {
          const contentId = tab.dataset.tab;
          const fileExists = files.some(file => 
            `preview-${file.name.replace(/\./g, '-')}` === contentId
          );
          
          if (!fileExists) {
            tab.remove();
            const content = document.getElementById(contentId);
            if (content) content.remove();
          }
        });
        
        // If we're on a tab that no longer exists, switch to combined
        if (!document.querySelector(`.preview-tab.active`)) {
          switchPreviewTab('preview-combined');
        }
      } else {
        // Remove all individual file previews when not using separate files
        const allTabs = previewTabsEl.querySelectorAll('.preview-tab:not([data-tab="combined"])');
        allTabs.forEach(tab => {
          tab.remove();
          const contentId = tab.dataset.tab;
          const content = document.getElementById(contentId);
          if (content) content.remove();
        });
        
        // Ensure combined tab is active
        switchPreviewTab('preview-combined');
      }
      
      // Enable/disable download button
      downloadBtn.disabled = Object.keys(filteredData).length === 0;
      
      // Validate references if enabled
      if (validateReferencesCheckbox.checked) {
        referenceProblems = validateReferences(filteredData);
        updateValidationStatus();
      }
    }
    
    // Function to switch between preview tabs
    function switchPreviewTab(tabId) {
      // Remove active class from all tabs and content
      document.querySelectorAll('.preview-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.preview-content').forEach(content => content.classList.remove('active'));
      
      // Add active class to selected tab and content
      if (tabId === 'preview-combined') {
        document.querySelector('.preview-tab[data-tab="combined"]').classList.add('active');
        document.getElementById('preview-combined').classList.add('active');
      } else {
        document.querySelector(`.preview-tab[data-tab="${tabId}"]`).classList.add('active');
        document.getElementById(tabId).classList.add('active');
      }
      
      currentPreviewTab = tabId;
    }
    
    // Function to update validation status display
    function updateValidationStatus() {
      if (!validateReferencesCheckbox.checked) {
        validationStatusEl.style.display = 'none';
        return;
      }
      
      validationStatusEl.style.display = 'block';
      
      if (referenceProblems.length === 0) {
        validationStatusEl.innerHTML = `
          <div class="validation-status success">
            <div class="validation-status-icon">✓</div>
            <div class="validation-status-message">
              All references are valid! Your tokens are ready to use with Style Dictionary.
            </div>
          </div>
        `;
      } else {
        validationStatusEl.innerHTML = `
          <div class="validation-status error">
            <div class="validation-status-icon">⚠️</div>
            <div class="validation-status-message">
              Found ${referenceProblems.length} reference ${referenceProblems.length === 1 ? 'problem' : 'problems'}. 
              Click "Validate References" to see details.
            </div>
          </div>
        `;
      }
    }
    
    // Function to show detailed validation results
    function showValidationResults() {
      if (referenceProblems.length === 0) {
        statusEl.innerHTML = `
          <div class="success">
            All references are valid! Your tokens are ready to use with Style Dictionary.
          </div>
        `;
        statusEl.className = "success";
      } else {
        let html = `<div class="warning">Found ${referenceProblems.length} reference problems:</div><ul>`;
        
        // Show up to 5 problems to avoid overwhelming the UI
        const displayProblems = referenceProblems.slice(0, 5);
        
        for (const problem of displayProblems) {
          html += `<li class="reference-problem">
                    Token at <strong>${problem.path}</strong> 
                    references <strong>${problem.reference}</strong> which cannot be resolved
                   </li>`;
        }
        
        if (referenceProblems.length > 5) {
          html += `<li>...and ${referenceProblems.length - 5} more problems</li>`;
        }
        
        html += '</ul>';
        
        html += `<div class="validation-tools">
                  <p>Recommendations:</p>
                  <ul>
                    <li>Make sure all collections and modes containing referenced tokens are selected</li>
                    <li>Try using the "Flat Structure" option for easier reference resolution</li>
                    <li>Check that references use the correct path format</li>
                  </ul>
                </div>`;
        
        statusEl.innerHTML = html;
        statusEl.className = "warning";
      }
    }
    
    // Function to toggle all collections and their modes
    function toggleAllCollections() {
      areAllCollectionsSelected = !areAllCollectionsSelected;
      toggleAllCollectionsBtn.textContent = areAllCollectionsSelected ? 'Deselect All' : 'Select All';
      
      // Get all collection checkboxes
      const collectionCheckboxes = collectionsAndModesEl.querySelectorAll('.collection-checkbox');
      
      // Toggle each collection and its modes
      collectionCheckboxes.forEach(checkbox => {
        checkbox.checked = areAllCollectionsSelected;
        const collectionId = checkbox.dataset.collection;
        
        // Also toggle all mode checkboxes for this collection
        const modeCheckboxes = collectionsAndModesEl.querySelectorAll(`.mode-checkbox[data-collection="${collectionId}"]`);
        modeCheckboxes.forEach(modeCheckbox => {
          modeCheckbox.checked = areAllCollectionsSelected;
        });
        
        // Update the collection's collapsed state
        updateCollectionDisplay(collectionId, areAllCollectionsSelected);
      });
      
      // Update selectedCollections and selectedModes
      updateSelectionArrays();
      
      // Update the preview
      updatePreviews();
    }
    
    // Function to toggle collapse/expand for a collection
    function toggleCollectionExpand(collectionId) {
      const modesContainer = document.getElementById(`collection-${collectionId}-modes`);
      const chevron = document.querySelector(`#collection-${collectionId}-header .chevron`);
      
      if (modesContainer.style.display === 'none') {
        modesContainer.style.display = 'block';
        chevron.classList.remove('collapsed');
      } else {
        modesContainer.style.display = 'none';
        chevron.classList.add('collapsed');
      }
    }
    
    // Function to update collection display based on selection
    function updateCollectionDisplay(collectionId, isSelected) {
      // For now, keep expanded regardless of selection state
      const modesContainer = document.getElementById(`collection-${collectionId}-modes`);
      if (modesContainer) {
        modesContainer.style.display = 'block';
      }
    }
    
    // Function to update selection arrays based on checkboxes
    function updateSelectionArrays() {
      selectedCollections = [];
      selectedModes = {};
      
      // Get all checked collection checkboxes
      const collectionCheckboxes = collectionsAndModesEl.querySelectorAll('.collection-checkbox:checked');
      
      // For each checked collection, add it to selectedCollections and process its modes
      collectionCheckboxes.forEach(checkbox => {
        const collectionId = checkbox.dataset.collection;
        selectedCollections.push(collectionId);
        selectedModes[collectionId] = [];
        
        // Get all checked mode checkboxes for this collection
        const modeCheckboxes = collectionsAndModesEl.querySelectorAll(`.mode-checkbox[data-collection="${collectionId}"]:checked`);
        modeCheckboxes.forEach(modeCheckbox => {
          selectedModes[collectionId].push(modeCheckbox.dataset.mode);
        });
      });
    }
    
    // Function to build nested collection and mode checkboxes
    function buildCollectionAndModesList() {
      if (!tokenData) return;
      
      collectionsAndModesEl.innerHTML = '';
      const collections = Object.keys(tokenData);
      
      if (collections.length === 0) {
        collectionsAndModesEl.innerHTML = '<div>No collections found</div>';
        return;
      }
      
      // Clear selected collections and modes
      selectedCollections = [];
      selectedModes = {};
      
      // Process each collection
      collections.forEach(collection => {
        // Create collection container
        const collectionItem = document.createElement('div');
        collectionItem.className = 'collection-item';
        collectionItem.id = `collection-${collection}`;
        
        // Create collection header
        const collectionHeader = document.createElement('div');
        collectionHeader.className = 'collection-header';
        collectionHeader.id = `collection-${collection}-header`;
        collectionHeader.addEventListener('click', () => toggleCollectionExpand(collection));
        
        // Add chevron icon
        const chevron = document.createElement('span');
        chevron.className = 'chevron';
        collectionHeader.appendChild(chevron);
        
        // Create collection checkbox
        const collectionCheckbox = document.createElement('input');
        collectionCheckbox.type = 'checkbox';
        collectionCheckbox.className = 'collection-checkbox';
        collectionCheckbox.id = `collection-${collection}-checkbox`;
        collectionCheckbox.dataset.collection = collection;
        collectionCheckbox.checked = true;
        
        // Stop propagation to prevent expand/collapse when clicking the checkbox
        collectionCheckbox.addEventListener('click', (e) => e.stopPropagation());
        
        collectionCheckbox.addEventListener('change', () => {
          // Toggle all mode checkboxes for this collection
          const modeCheckboxes = collectionsAndModesEl.querySelectorAll(`.mode-checkbox[data-collection="${collection}"]`);
          modeCheckboxes.forEach(modeCheckbox => {
            modeCheckbox.checked = collectionCheckbox.checked;
          });
          
          // Update selection arrays
          updateSelectionArrays();
          
          // Update the previews
          updatePreviews();
          
          // Update the "Select All" button state
          const allCollectionCheckboxes = collectionsAndModesEl.querySelectorAll('.collection-checkbox');
          areAllCollectionsSelected = Array.from(allCollectionCheckboxes).every(cb => cb.checked);
          toggleAllCollectionsBtn.textContent = areAllCollectionsSelected ? 'Deselect All' : 'Select All';
        });
        
        // Create collection label
        const collectionLabel = document.createElement('label');
        collectionLabel.htmlFor = `collection-${collection}-checkbox`;
        
        // Count modes in this collection
        const modesCount = Object.keys(tokenData[collection]).length;
        collectionLabel.textContent = `${collection} (${modesCount} modes)`;
        
        // Add checkbox and label to header
        collectionHeader.appendChild(collectionCheckbox);
        collectionHeader.appendChild(collectionLabel);
        
        // Add header to collection item
        collectionItem.appendChild(collectionHeader);
        
        // Create modes container
        const modesContainer = document.createElement('div');
        modesContainer.className = 'collection-modes';
        modesContainer.id = `collection-${collection}-modes`;
        
        // Add collection to selection arrays
        selectedCollections.push(collection);
        selectedModes[collection] = [];
        
        // Add mode checkboxes
        const modes = Object.keys(tokenData[collection]);
        modes.forEach(mode => {
          const modeDiv = document.createElement('div');
          modeDiv.className = 'checkbox-item';
          
          const modeCheckbox = document.createElement('input');
          modeCheckbox.type = 'checkbox';
          modeCheckbox.className = 'mode-checkbox';
          modeCheckbox.id = `collection-${collection}-mode-${mode}`;
          modeCheckbox.dataset.collection = collection;
          modeCheckbox.dataset.mode = mode;
          modeCheckbox.checked = true;
          
          modeCheckbox.addEventListener('change', () => {
            // Check if any mode is checked for this collection
            const modesChecked = collectionsAndModesEl.querySelectorAll(`.mode-checkbox[data-collection="${collection}"]:checked`).length > 0;
            
            // Update collection checkbox based on mode selection
            const collectionCheckbox = document.getElementById(`collection-${collection}-checkbox`);
            if (collectionCheckbox) {
              collectionCheckbox.checked = modesChecked;
            }
            
            // Update selection arrays
            updateSelectionArrays();
            
            // Update the previews
            updatePreviews();
          });
          
          const modeLabel = document.createElement('label');
          modeLabel.htmlFor = `collection-${collection}-mode-${mode}`;
          modeLabel.textContent = mode;
          
          modeDiv.appendChild(modeCheckbox);
          modeDiv.appendChild(modeLabel);
          modesContainer.appendChild(modeDiv);
          
          // Add to selected modes
          selectedModes[collection].push(mode);
        });
        
        // Add modes container to collection item
        collectionItem.appendChild(modesContainer);
        
        // Add collection item to DOM
        collectionsAndModesEl.appendChild(collectionItem);
      });
      
      // Set all collections selected by default
      areAllCollectionsSelected = true;
      toggleAllCollectionsBtn.textContent = 'Deselect All';
      
      // Update previews
      updatePreviews();
    }
    
    // Helper function to download single JSON file
    function downloadJson(data, filename) {
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      
      URL.revokeObjectURL(url);
    }
    
    // Function to download multiple files as a zip (or one by one for simplicity)
    function downloadMultipleFiles(files) {
      // If only one file, download it directly
      if (files.length === 1) {
        downloadJson(files[0].data, files[0].name);
        return;
      }
      
      // Create a temporary link for each file
      const fileLinks = document.createElement('div');
      fileLinks.style.display = 'none';
      document.body.appendChild(fileLinks);
      
      let html = '<p>Multiple files are ready for download:</p><ul>';
      
      files.forEach((file, index) => {
        const jsonStr = JSON.stringify(file.data, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = file.name;
        a.textContent = `Download ${file.name}`;
        a.id = `download-link-${index}`;
        a.className = 'download-link';
        
        fileLinks.appendChild(a);
        
        html += `<li><a href="#" onclick="document.getElementById('download-link-${index}').click(); return false;">${file.name}</a></li>`;
      });
      
      html += '</ul>';
      
      // Show download links in status panel
      statusEl.innerHTML = html;
      statusEl.className = "success";
      
      // Auto-click the first download link
      const firstLink = fileLinks.querySelector('.download-link');
      if (firstLink) {
        firstLink.click();
      }
    }
    
    // Initialize UI
    document.addEventListener('DOMContentLoaded', () => {
      console.log("UI loaded and initialized");
      statusEl.textContent = "Extracting tokens...";
      statusEl.className = "info";
      
      // Format option changes
      formatDTCGRadio.addEventListener('change', updatePreviews);
      formatLegacyRadio.addEventListener('change', updatePreviews);
      validateReferencesCheckbox.addEventListener('change', () => {
        updatePreviews();
        updateValidationStatus();
      });
      flatStructureCheckbox.addEventListener('change', updatePreviews);
      
      separateFilesCheckbox.addEventListener('change', () => {
        // When toggling separate files, update the preview tabs
        updatePreviews();
        
        // Show/hide tabs based on separate files setting
        const tabsContainer = document.getElementById('preview-tabs');
        if (separateFilesCheckbox.checked) {
          tabsContainer.style.display = 'flex';
        } else {
          tabsContainer.style.display = 'none';
          // Ensure combined preview is active
          switchPreviewTab('preview-combined');
        }
      });
      
      // Toggle all collections button
      toggleAllCollectionsBtn.addEventListener('click', toggleAllCollections);
      
      // Validate references button
      validateBtn.addEventListener('click', () => {
        // Request validation from the plugin
        statusEl.textContent = "Validating references...";
        statusEl.className = "info";
        parent.postMessage({ pluginMessage: { type: 'validate-references' } }, '*');
      });
      
      // Extract button handler
      extractBtn.addEventListener('click', () => {
        outputEl.textContent = "Loading data...";
        statusEl.textContent = "Extracting tokens...";
        statusEl.className = "info";
        
        collectionsAndModesEl.innerHTML = `
          <div class="loading">
            <div class="spinner"></div>
            Loading collections and modes...
          </div>
        `;
        
        // Hide validation status when refreshing
        validationStatusEl.style.display = 'none';
        
        downloadBtn.disabled = true;
        
        // Request token extraction
        parent.postMessage({ pluginMessage: { type: 'extract-tokens' } }, '*');
      });
      
      // Download button handler
      downloadBtn.addEventListener('click', () => {
        if (separateFilesCheckbox.checked) {
          // Generate separate files
          const files = getSeparateFiles();
          downloadMultipleFiles(files);
        } else {
          // Single file download
          const filteredData = getFilteredTokens();
          const format = formatDTCGRadio.checked ? 'dtcg' : 'legacy';
          const fileName = `design-tokens-${format}-${new Date().toISOString().split('T')[0]}.json`;
          downloadJson(filteredData, fileName);
          
          statusEl.textContent = "Tokens downloaded successfully!";
          statusEl.className = "success";
        }
      });
    });
    
    // Handle messages from the plugin
    window.onmessage = (event) => {
      console.log("UI received message:", event.data);
      
      if (event.data.pluginMessage) {
        const msg = event.data.pluginMessage;
        
        if (msg.type === 'tokens-data') {
          console.log("UI received tokens data");
          tokenData = msg.data;
          
          // Build the nested collections and modes list
          buildCollectionAndModesList();
          
          // Hide tabs initially for better UI
          if (!separateFilesCheckbox.checked) {
            document.getElementById('preview-tabs').style.display = 'none';
          }
          
          // Check for validation problems
          if (msg.validationProblems && msg.validationProblems.length > 0) {
            console.log("Validation problems:", msg.validationProblems.length);
            referenceProblems = msg.validationProblems;
            updateValidationStatus();
          } else {
            referenceProblems = [];
            updateValidationStatus();
          }
          
          statusEl.textContent = "Tokens extracted successfully!";
          statusEl.className = "success";
        } else if (msg.type === 'validation-result') {
          console.log("Validation result received");
          referenceProblems = msg.validationProblems || [];
          updateValidationStatus();
          showValidationResults();
        } else if (msg.type === 'error') {
          console.error("UI received error:", msg.message);
          outputEl.textContent = "Error: " + msg.message;
          statusEl.textContent = msg.message;
          statusEl.className = "error";
        }
      }
    };
    
    // Let the plugin know the UI is ready
    console.log("UI sending ready message to plugin");
    parent.postMessage({ pluginMessage: { type: 'ui-ready' } }, '*');
  </script>
</body>
</html>